package org.maths {			/**	 * A Complex Number class	 */	public class Complex {				/**		 * Real part		 */		public var x:Number;				/**		 * Imaginary part		 */		public var y:Number;				/**		 * Utility class responsible for configuring string representations etc.		 */		public static var util:Util = new Util();				/**		 * Precision to which we test for equality		 */		public static var precision:Number = 1e-14;				//-------				// INFINITY is the public version of this...		private static var infinity:Complex = null;				// ONE is the public version of this...		private static var one:Complex = null;				// ZERO is the public version of this...		private static var zero:Complex = null;			// I is the public version of this...		private static var eye:Complex = null;				// so we can store variables in a Complex type		//private var symbolValue:String = null;				// Booleans have true == 1, false == 0					private static const inverse:Object = {			negate:"negate",			reciprocal:"reciprocal",			conjugate:"conjugate",			abs:"abs",			exp:"ln",			ln:"exp",			sqr:"sqrt",			sqrt:"sqr",			cube:"cbrt",			cbrt:"cube",			cos:"acos",			acos:"cos",			sin:"asin",			asin:"sin",			tan:"atan",			atan:"tan"			}						/**		 * Construct a new Complex number object		 * @param xr Real Component or Radial Component if polar		 * @param ytheta Imaginary Component or Argument if polar		 * @param polar True if polar, but defaults to false which means cartesian		 */		function Complex(xr:Object, ytheta:Number=0, polar:Boolean=false) {		    if(xr is Complex) {				x = Complex(xr).x;				y = Complex(xr).y;		    }			if(polar) {				x = Number(xr)*Math.cos(ytheta);				y = Number(xr)*Math.sin(ytheta);			}			else if(xr is Number) {				this.x = Number(xr);				this.y = (Object(ytheta) == null) ? 0 : ytheta;			}		}				/**		 * Returns Complex infinity. Unfortunately this can't be a constant as it would lead to a recursive		 * definition of the Complex class. (new Complex() would call new Complex() in order to create INFINITY)		 */		public static function get INFINITY():Complex {			if(infinity == null) {				infinity = new Complex(Number.POSITIVE_INFINITY);			}			return infinity;		}			/**		 * Complex one.		 */		public static function get ONE():Complex {			if(one == null) {				one = new Complex(1);			}			return one;		}				/**		 * Complex zero.		 */		public static function get ZERO():Complex {			if(zero == null) {				zero = new Complex(0);			}			return zero;		}				/**		 * Complex I.		 */		public static function get I():Complex {			if(eye == null) {				eye = new Complex(0,1);			}			return eye;		}						public static function hasFunction(s:String):Boolean {			try {				var z:Complex = new Complex(0,0);				var f:Object = z[s];				return z[s] is Function;				return Complex[s] is Function;			}			catch(err:Error) {				return false;			}			return false;		}				//public function isSymbol():Boolean {		//	return symbolValue != null;		//}				//		// Relational expressions:		//		public function boolEquals(c:Complex):Boolean {			return (minus(c).length < precision) || (!finite() && !c.finite());		}				public function equals(c:Complex):Complex {			return boolEquals(c) ? new Complex(1) : new Complex(0);		}				public function notEquals(c:Complex):Complex {			return boolEquals(c) ? new Complex(0) : new Complex(1);		}				public function logicalNot():Complex {			return (x==1 && y==0) ? new Complex(1) : new Complex(0);		}				//		// Relational expressions which require real operands		//		public function greaterThan(c:Complex):Complex {			if(y != 0 || c.y != 0) {				throw new Error(""+this + " and " + c + " cannot be compared");			}			if(x > c.x) {				return new Complex(1);			}			else {				return new Complex(0);			}		}				public function greaterEquals(c:Complex):Complex {			if(y != 0 || c.y != 0) {				throw new Error(""+this + " and " + c + " cannot be compared");			}			if(x >= c.x) {				return new Complex(1);			}			else {				return new Complex(0);			}		}				public function lessThan(c:Complex):Complex {			if(y != 0 || c.y != 0) {				throw new Error(""+this + " and " + c + " cannot be compared");			}			if(x < c.x) {				return new Complex(1);			}			else {				return new Complex(0);			}		}				public function lessEquals(c:Complex):Complex {			if(y != 0 || c.y != 0) {				throw new Error(""+this + " and " + c + " cannot be compared");			}			if(x <= c.x) {				return new Complex(1);			}			else {				return new Complex(0);			}		}				public function times(z:Object):Complex {			if(zfinite(z)) {				if(z is Number) {					var zn:Number = Number(z);					return new Complex(x*zn, y*zn, false);				}				if(z is Complex) {					return new Complex(x*z.x-y*z.y, x*z.y+y*z.x);				}			}			return INFINITY; // ignore INFINITY*0 case		}				public function over(z:Object):Complex {			if(zfinite(z)) {				if(z is Number) {					var zn:Number = Number(z);					return zn == 0 ? INFINITY: new Complex(x/zn, y/zn);				}				var d:Number = z.x*z.x + z.y*z.y;				return d == 0 ? INFINITY: new Complex((x*z.x+y*z.y)/d, (-x*z.y+y*z.x)/d);			}			else {				if(finite()) {					return new Complex(0);				}				else {					return INFINITY;				}			}		}				public function plus(z:Object):Complex {			if(!zfinite(z)) return INFINITY;			if(z is Number) {				return new Complex(x+z, y);			}			return new Complex(x+z.x, y+z.y);		}				public function minus(z:Object):Complex {			if(!zfinite(z)) return INFINITY;			if(z is Number) {				return new Complex(x-Number(z), y);			}			return new Complex(x-z.x, y-z.y);		}				public function negate():Complex {			if(!finite()) return INFINITY;			return new Complex(-x,-y);		}				public function conjugate():Complex {			if(!finite()) return INFINITY;			return new Complex(x, -y);		}				public function reciprocal():Complex {			if(finite()) {				var d:Number = x*x - y*y;				return d == 0 ? INFINITY: (new Complex(1)).over(this);			}			return new Complex(0);		}				public function abs():Complex {			if(!finite()) return INFINITY;			return new Complex(length, 0);		}				public function arg():Complex {			if(!finite()) return new Complex(0);			return new Complex(angle, 0);		}				public function exp():Complex {			if(!finite()) return INFINITY;			var ex:Number = Math.exp(x);			return new Complex(ex*Math.cos(y), ex*Math.sin(y));		}				public function sin():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.sin(x));			var eiz:Complex = (new Complex(-y,x)).exp();			var emiz:Complex = (new Complex(y,-x)).exp();			return eiz.minus(emiz).over(new Complex(0,2));		}				public function asin():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.asin(x));			var i:Complex = new Complex(0,1);			var w:Complex = ((new Complex(1)).minus(times(this))).sqrt().plus(times(i));			return w.ln().times(i).negate();		}				public function cos():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.cos(x));			var eiz:Complex = (new Complex(-y,x)).exp();			var emiz:Complex = (new Complex(y,-x)).exp();			return eiz.plus(emiz).over(2);		}				public function acos():Complex {			//pi/2+i*ln(i*z+sqrt(1-z^2))			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.acos(x));			var i:Complex = new Complex(0,1);			var w:Complex = ((new Complex(1)).minus(times(this))).sqrt().times(i).plus(times(i));			return w.ln().times(i).plus(new Complex(Math.PI/2));		}				public function tan():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.tan(x));			return sin().over(cos());		}					public function atan():Complex {			//(ln(1-iz)-ln(1+iz))*i/2			if(!finite()) return new Complex(Math.PI/2);			if(negligible(y))				return new Complex(Math.atan(x));			var i:Complex = new Complex(0,1);			var one:Complex = new Complex(1);			var iz:Complex = times(i);			var ln1:Complex = one.minus(iz).ln();			var ln2:Complex = one.plus(iz).ln();			return ln1.minus(ln2).times(i).over(2);		}				public function sinh():Complex {			if(!finite()) return INFINITY;			var ez:Complex = exp();			var emz:Complex = (new Complex(-x,-y)).exp();			//trace(ez.minus(emz).over(2));			return ez.minus(emz).over(2);		}				public function asinh():Complex {			if(!finite()) return INFINITY;			// ln(z)+sqrt(1+z^2)			return ln().plus((sqr().plus(new Complex(1))).sqrt());		}				public function cosh():Complex {			if(!finite()) return INFINITY;			var ez:Complex = exp();			var emz:Complex = (new Complex(-x,-y)).exp();			//trace(ez.plus(emz).over(2));			return ez.plus(emz).over(2);		}				public function acosh():Complex {			if(!finite()) return INFINITY;			// ln(z)+sqrt(1+z^2)			return ln().plus((sqr().minus(new Complex(1))).sqrt());		}				public function tanh():Complex {			if(!finite()) return INFINITY;			return sinh().over(cosh());		}			public function atanh():Complex {			if(!finite()) return INFINITY;			var one:Complex = new Complex(1);			return plus(one).ln().minus(one.minus(ln())).over(2);		}				public function ln():Complex {			if(!finite()) return INFINITY;			var len:Number = length;			return negligible(len) ? INFINITY: new Complex(Math.log(len), angle); 		}				public function sqrt():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return x >=0 ? new Complex(Math.sqrt(x)) : new Complex(0, Math.sqrt(-x));			return ln().times(0.5).exp();		}				public function sqr():Complex {			if(!finite()) return INFINITY;			return times(this);		}				public function cbrt():Complex {			if(!finite()) return INFINITY;			if(negligible(y))				return new Complex(Math.pow(x,1/3));			return ln().times(1/3).exp();		}				public function cube():Complex {			if(!finite()) return INFINITY;			return times(this).times(this);		}				public function pow(z:Object):Complex {			if(!finite()) return INFINITY;			if(x == 0 && y == 0 && z.x>0 && z.y ==0) return Complex.ZERO;			var log:Complex = ln();			//return log.finite() ? ln().times(z).exp() : (z.x > 0) ? ZERO : INFINITY;			return log.finite() ? ln().times(z).exp() : INFINITY;		}				public function round():Complex {			if(!finite()) return INFINITY;			return new Complex(Math.round(x), Math.round(y));		}				public function get length():Number {			if(!finite()) return Number.POSITIVE_INFINITY;			return Math.sqrt(x*x+y*y);		}				public function get angle():Number {			if(!finite()) return 0;			return Math.atan2(y,x);		}				public function polar():Object {			return {r:length, theta:angle};		}	 	public function negligible(t:Number):Boolean {			return Math.abs(t) < precision;		}				public function finite():Boolean {			var b:Boolean = isFinite(x) && isFinite(y);			if(!b)				trace("finite() false");			return b;		}				public function zfinite(z:Object):Boolean {			if(z is Complex) {				return finite() && z.finite();			}			else {				return isFinite(z.valueOf());			}		}				public function nan():Boolean {			return isNaN(x) || isNaN(y);		}				public function specialString():String {			if(!finite()) {				return "Error";			}			if(nan()) {				return "NaN";			}			if(negligible(y) && Math.abs(x) < 4 && Math.abs(x) > 2) {				if(negligible(x-Math.E)) 					return "e";				if(negligible(x+Math.E)) {					return "-e";				}				if(negligible(x-Math.PI)) 					return "pi";				if(negligible(x+Math.PI)) 					return "-pi";			}			return null		}				public function fullString():String {			var s:String;			if((s=specialString())!=null) {				return s;			}				if(negligible(y)) {							return ""+x;			}			var im:String;			if(y<0) {				im = negligible(y+1) ? "-i" : ""+y+"*i";				return negligible(x) ? im : "" + x +im;			}			else {				im = negligible(y-1) ? "i" : ""+y+"*i";				return negligible(x) ? im : "" + x + "+" +im;			}		}				/**		 * Return a full precision string representation in Cartesian form		 */		public function toString():String {			var s:String;			if((s=specialString())!=null) {				return s;			}			return fullString();		}				/**		 * Return a rounded string representation in cartesian form		 */		public function displayString():String {			var s:String;			if((s=specialString())!=null) {				return s;			}				var z:Complex = new Complex(util.round(x),util.round(y));			return z.fullString();		}				/**		 * Return a rounded string representation in polar form		 */		public function polarString():String {			return ""+util.round(length)+"cis("+util.round(angle*180/Math.PI)+"º)";		}					public function dot(z:Complex):Number {			return x*z.x + y*z.y;		}	}}