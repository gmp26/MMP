package org.maths {			/**	 * A Base class for Field implementations (such as IField)	 */	public class FieldBase {				/**		 * e.g. Real part, but may be numerator 		 */		public var x:Object;				/**		 * e.g. Imaginary part, but may be denominator		 */		public var y:Object;				/**		 * Utility class responsible for configuring string representations etc.		 */		public static var util:Util = new Util();				/**		 * Precision to which we test for equality		 */		public static var precision:Number = 1e-14;				//-------				// INFINITY is the public version of this...		private static var infinity:IField = null;				// ONE is the public version of this...		private static var one:IField = null;				// ZERO is the public version of this...		private static var zero:IField = null;			// I is the public version of this...		private static var eye:IField = null;				// so we can store variables in a IField type		//private var symbolValue:String = null;				// Booleans have true == 1, false == 0					private static const inverse:Object = {			negate:"negate",			reciprocal:"reciprocal",			conjugate:"conjugate",			abs:"abs",			exp:"ln",			ln:"exp",			sqr:"sqrt",			sqrt:"sqr",			cos:"acos",			acos:"cos",			sin:"asin",			asin:"sin",			tan:"atan",			atan:"tan"			}						/**		 * Construct a new IField number object		 * @param xr Real Component or Radial Component if polar		 * @param ytheta Imaginary Component or Argument if polar		 * @param polar True if polar, but defaults to false which means cartesian		 */		function FieldBase(xr:*, ytheta:*=null, polar:Boolean=false) {		    if(xr is IField) {				x = IField(xr).x;				y = IField(xr).y;		    }			if(polar) {				if(ytheta == null) ytheta = 0;				x = Number(xr)*Math.cos(ytheta);				y = Number(xr)*Math.sin(ytheta);			}			else if(xr is Number) {				this.x = Number(xr);				this.y = (ytheta == null) ? 0 : ytheta;			}		}				/**		 * Returns IField infinity. Unfortunately this can't be a constant as it would lead to a recursive		 * definition of the IField class. (new IField() would call new IField() in order to create INFINITY)		 */		public static function get INFINITY():IField {			if(infinity == null) {				infinity = new IField(Number.POSITIVE_INFINITY);			}			return infinity;		}			/**		 * IField one.		 */		public static function get ONE():IField {			if(one == null) {				one = new IField(1);			}			return one;		}				/**		 * IField zero.		 */		public static function get ZERO():IField {			if(zero == null) {				zero = new IField(0);			}			return zero;		}				/**		 * IField I.		 */		public static function get I():IField {			if(eye == null) {				eye = new IField(0,1);			}			return eye;		}						/**		 * Override in subClasses to check whether the class supports a function		 *  		 * @param s		 * @return 		 * 		 */		public static function hasFunction(s:String):Boolean {			try {				var z:IField = new FieldBase(0,0);				var f:Object = z[s];				return z[s] is Function;				return FieldBase[s] is Function;			}			catch(err:Error) {				return false;			}			return false;		}				//		// Relational expressions:		//		public function boolEquals(c:IField):Boolean {			return (minus(c).length < precision) || (!finite() && !c.finite());		}				public function equals(c:IField):IField {			return boolEquals(c) ? new IField(1) : new IField(0);		}				public function notEquals(c:IField):IField {			return boolEquals(c) ? new IField(0) : new IField(1);		}				public function logicalNot():IField {			return (x==1 && y==0) ? new IField(1) : new IField(0);		}					 	public function negligible(t:Number):Boolean {			return Math.abs(t) < precision;		}				public function zfinite(z:Object):Boolean {			if(z is IField) {				return isFinite(x) && isFinite(y) && isFinite(z.x) && isFinite(z.y);			}			else {				return isFinite(z.valueOf());			}		}				public function nan():Boolean {			return isNaN(x) || isNaN(y);		}				/**		 * Return a full precision string representation in Cartesian form		 */		public function toString():String {			var s:String;			if((s=specialString())!=null) {				return s;			}			return fullString();		}			}}