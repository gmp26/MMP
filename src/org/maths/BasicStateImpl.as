package org.maths {import flash.events.EventDispatcher;//import mx.utils.Delegate;import org.maths.Complex;//import PrimitiveSet;import org.maths.Expression;import org.maths.Commands;import org.maths.IState;//// Use this class to define the commands understood by Expression syntax and to store// any defined variables.//// The base implementation is useful when you don't need to track geometric views or// any metadata that may be associated with an Expression. //public class BasicStateImpl extends EventDispatcher implements IState {	public var variables:Object = {};	private var cache:Object = {};	public var commands:Commands;		function BasicStateImpl() {		//trace("BasicStateImpl:24: new BasicStateImpl()");		variables = {};		cache = {}; // value cache		commands = new Commands();		Expression.state = this;	}		//	// TODO:	//	// Delegate commands to the subject of the command.	//		public function executeCommand(name:String, varName:String, expr1:Expression):Complex {		var rv:Complex = commands.executeCommand(name, varName, expr1);		return (rv == null) ? new Complex(varName + " " + name + expr1) : rv;	}		public function commandDisplayName(name:String):String {		return commands.displayName(name);	}		public function hasCommand(name:String):Boolean {		//try {			return commands.hasCommand(name);		//}		//catch(err:Error) {		//}		//return false;	}		public function reset():void {		//trace("BasicStateImpl: 49: reset()");		variables = {};		cache = {};	}		public function setValue(varName:String, value:Complex):void {		cache[varName] = value;	}		public function getValue(varName:String):Complex {		//trace("BasicStateImpl:55 var " + varName + " = " + Complex(cache[varName]));		return Complex(cache[varName]);	}		public function define(varName:String, rvalue:Expression):Complex {		variables[varName]=rvalue;		return revalue(varName).current;		//trace("BasicStateImpl:69 defining " + varName + "=" + rvalue);	}		public function getDefinition(varName:String):Expression {		return Expression(variables[varName]);	}		public function revalue(varName:String):Object {		var prev:Object = cache[varName];		return {prev:prev, current: cache[varName]=Expression(variables[varName]).evaluate()};	}		public function setColor(lvalue:Expression, rvalue:Expression):void {	}}}